# Core Script

```yaml
video_script:
  Content: "[]"
  prompt: 
    - "One page compatible with Elgato prompter"
    - "Text output use emojis"
    - "Expand or shrink for 100 words"
    - "Do not update [[]] for obsidian reference"
    - "For each slide rewrite and fix syntax for the prompter > target 100 words"
    - "Header formart L01-v1-[summarycontent]-tell-show "
    - "Example: #### **LO1-V4:START-GITHUB-ACTIONS-WITH-YAML-TELL-SHOW** ⚙️  
To get GitHub Actions running, start with a **simple YAML workflow**. [SHOW] YAML (Yet Another Markup Language) is the backbone of most modern platform configurations—essential for defining CI/CD pipelines, infrastructure, and deployment rules.  
[DO] I recommend using **GPT to help generate or review** your YAML files. In this repo, all prompts and examples are GPT-assisted. Ask it to explain or **add comments** if anything feels unclear. This makes your workflows not just functional, but understandable. YAML is your **config language for infra**, so mastering it will pay off across platforms. 🧠📁"
    
```
####### todos
- check the index id
- set the headers with lo lo2 lo3

## Text Output >

### Active Script 
##### Intro-S1-Hook
Welcome to our [[SonarQube]] course!
In today’s fast-paced world, delivering high-quality software isn’t just about writing code.
it’s about [[Connecting Dots]] catching issues early and keeping [[technical debt]] in check.
With [[SonarQube]] course, you’ll learn how to add your projects to integrate them for analysing of code, and ensure release readiness throughout your [[development lifecycle.]]
Most important of all we would be able to learn to fix the issues in first principles based approach to fix it.
Let’s get started and transform the way [[you approach software]]!

##### Intro-S2-Objective
In this course, you'll master:
- Setting up SonarQube in a development environment - [[elephant eat it first]]
- Integrating [[SonarQube project]] CI/CD pipelines - enter into the world of [[fixing is at core]] pay the infra debt
- [[Analysing code quality]] and [[security vulnerabilities]] - with change


##### Intro-S3-[[Flex]]  
Hello, I'm Rifat Erdem Sahin. With over 40 successful [[IT contracts]] and [[80 projects]] delivered globally, I've honed deep expertise in the [[software development life cycle]]. At Accenture, it was the pivotal tool in my journey, which has enabled me to ensure code quality and maintainability across [[projects million man day projects]]. Integrating SonarQube into CI/CD pipelines has streamlined continuous integration to support trunk-based development for rapid, reliable code releases. In an ever-changing world, let's dive in and learn the components needed to make it work.

##### Intro-S4-Bonus
We're diving into an [[AI-first project]] where you'll harness the power of AI tools[[4.1_Iterated_prompts_onClaude]] to set up and optimize your own [[SonarQube environment]]. Along the way, you'll [[sharpen your skills]] in [[AI-assisted development]] and ensure your workflows meet top-tier quality standards. By the end of this course, you’ll not only understand how to [[integrate]] AI into your software development pipeline—you’ll also be confidently applying it for fixing continuous integration and automated quality checks with tools like SonarQube. Bonus: You’ll walk away with a fully functional, portfolio-ready project to showcase your skills to the world!

##### Intro-S5-portfolio-apply
[Check out LinkedIn for the projects that i have used the sonarqube to pay the technical debt and contracts that are mentioned here. Also follow the links to go to GitHub where I am sharing all the code that is needed for this course and check out the portfolio projects over there. Building a portfolio on GitHub for IT professionals matters, and SonarQube would complement it by making sure the quality of the software meets the requirements for the customers who are seeking easily updatable applications at high quality.]("8.3.LinkedinAndGitHub.mp4")

##### Lo1-v1-s1-whatsissonarqubet-tell-show
What is SonarQube and Why Do We Need It?
SonarQube is an essential tool in modern software development. Think of software as a building—it's not just about constructing it but maintaining its quality over time. In the Software Development Life Cycle [4.20.1_sonarqube_cycle.png](SDLC), technical debt accumulates as new requirements emerge. This is a normal part of development, but managing this debt effectively is critical.
The SDLC helps us package and address technical debt until new requirements arise. The key question is: when do we tackle this debt, and how do we allocate time for it? For a project to move forward, we need a structured process to measure and manage technical debt, much like using a scale to track progress.
In today’s fast-paced world, AI is accelerating the rate of change, making it even more important to have tools like SonarQube. It provides a clear environment to measure, analyze, and reduce technical debt, ensuring your software remains maintainable and scalable.

##### Lo1-v1-s1-sonarqube-benefits-tell
SonarQube offers a comprehensive view of your code quality, helping you maintain high standards and improve your development process. Here are four key benefits:
- **Multi-language Support**: SonarQube supports more than 25 programming languages, making it a versatile tool for diverse development teams.
- **Team Collaboration**: SonarQube helps maintain a standard of code quality within your development team, fostering better collaboration and consistency.
- **Debt Management**: By identifying and addressing technical debt, SonarQube allows you to focus on adding new features while keeping your codebase maintainable.
These benefits make SonarQube an essential tool for modern software development.
- **CI/CD Integration**: It seamlessly integrates into your CI/CD pipeline, enabling continuous code quality checks with every commit.Elephant we need to sort out!

##### Lo1-v2-s1-Setup pick environment-tell-show 
Our initial objective is to set up the environment effectively. The most challenging setup will be for production, but in this course, we are focusing on building a portfolio and presenting your ideas confidently. To achieve this, we will concentrate on Proof of Concept environments, which are primarily infrastructure-as-code-based setups such as Codespaces.
While choosing the environment, it’s natural to have preferences. For instance, I am building this course on [4.2_windows_structure_install.png](Windows) but have chosen to work on Codespaces. The key takeaway is to learn how to restore and fix SonarQube components by applying first principles. This foundational knowledge mixed with AI first implementation will empower you to handle any environment with confidence.

##### LO1-v2-s2-shortcuts-tell-show
The ultimate shortcut is to use a [4.18.1_cloud_implementations.png](cloud-based rental system) for SonarQube. This eliminates the need for setup, allowing you to quickly start scanning projects. While this approach is convenient, it’s crucial to understand the deployment components, as SonarQube is often used in enterprise environments. Learning these fundamentals ensures a first-principles approach, enabling you to adapt to various project requirements. We’re focusing on this method not because it’s easy, but because mastering the setup process builds a deeper understanding. This knowledge is invaluable, especially when working with dynamic environments like Codespaces, which can be ephemeral by nature.

##### LO1-v2-s3-infradebt-tell-show  
SonarQube is a tool for managing technical debt, a critical yet often overlooked concept in IT. Technical debt refers to the compromises made in infrastructure or code that may lead to future challenges. In this course, we rely on GitHub Codespaces to host processes for running SonarQube. While the free tier contract(debt) offers a limited timeline, it introduces potential trade-offs, such as resource shutdowns. Students should focus on understanding these trade-offs and learning how to restore components when needed. [4.19.1_codespacescost2025April.png](For basic usage in this course,) the free tier suffices, but exceeding limits may incur additional costs. Manage resources wisely!

##### LO1-v2-SettingUpEnvironment-tell  
For most students, accessing the environment requires virtualization. Setting up the environment is our primary goal and a critical task. We should approach it in a way that allows us to rebuild it with ease. This is about becoming skilled, and I wasn’t always in that position. Initially, I looked for shortcuts, but I’ve come to realize that this is one of the harder yet more meaningful ways to build it.  
The system we are building will face challenges staying online, but these challenges will provide valuable learning opportunities. My proof-of-concept choice is Linux and a cloud-based solution called Codespaces, which has a strong community behind it.  
As a side note, this might feel like a bit of "yak shaving," but this Kubernetes and cloud-based vision will pay off for IT professionals in the long run. Trust me, I was once skeptical of this approach, but it has proven to be invaluable.

##### LO1:v3:linuxBased-Show-Do
Our pick is GitHub Codespaces. First, create your GitHub account, repository, and Codespaces environment on the GitHub platform. Our goal is to access the Minikube resource, which has already been deployed there. The free account provides temporary access to run the `minikube start` command. 
There are no excuses, such as not having access to a machine or being unable to open a GitHub repository. Codespaces offers a portfolio-ready environment for IT professionals, including tools like GitHub Actions. 
Please open the terminal, run the command, and watch Minikube go online. Once it's running, we can proceed to install the SonarQube platform on it.

##### LO1-v3-Codespeaces-Terminal-Getting-UsedTo-Tell-show
When you're inside Codespaces with Minikube, you’re operating through multiple layers—your machine, the Codespaces host, then Minikube. Each level has its own role. Some commands must target the Minikube agent specifically—especially when [4.4_max_heap_count_settings.png](configuring) host-level settings. Keep in mind, you're interacting with: the host, Codespaces, Minikube, container runners, SonarQube, and finally the scanner. Understanding this stack is key to troubleshooting and setup. In SDLC that is going to be your main challange understand the integration and how the code flows to pay the techical debt.

##### LO1-v3-LearnToDeployInEnvironment-Show-Do
SonarQube is a multi-tier system—UI, backend logic, and a database.  You’ll deploy it into a new environment using **Minikube**, a local Kubernetes cluster configured to run multiple (components)[4.5_rolloutstart.md] . Kubernetes helps you manage and observe all parts of your deployment.  Let’s learn to deploy, inspect resources, and understand how everything fits together.Pod,Service,Deployment and Replica sets are internal component for the kubernetes to be able to run the processes. This course is not a kubernetes course. Still these are important concepts in the long run to learn in order to maintain the SonarQube in a containersed enterprise environment. 

##### LO4-V4:SETUP-ADMIN-PASSWORD-TELL-SHOW 
After launching SonarQube in Minikube, both the UI and database layers are active. The UI will prompt you to log in using the default credentials: admin/admin. Once logged in, you must reset the admin password. This new password is stored in the configuration database inside your Minikube environment. This step finalizes the initial setup and secures your SonarQube instance. As long as your Codespaces environment remains active, this password will persist. This process also confirms that the UI is correctly communicating with the backend and database, ensuring the system is ready to handle code scans and analysis tasks.


##### LO1-V4:SETUP-REPO-ENVIRONMENT-FIRST-PROJECT-TELL-SHOW
Set up the repository and environment to prepare for your first project. Our goal is to scan code automatically using SonarQube running in Minikube inside Codespaces. The code lives in the [4.8_GITHUB.PNG](GitHub repository) — that’s what we’ll scan. The environment and the code are separate: we maintain the repo and the scanner seperately, not the same thing. Codespaces, which includes Minikube and SonarQube, will pull the repo and run a scan on every commit. — Watch how the repository in Github actions with our agent in the following steps [XXX](connects).

##### LO1-V4:GITHUB-SETUP-TELL-SHOW
The GitHub setup is critical to get all systems working in the background. You’ll need to authorize access and create both an App ID and a [SHOW](Client ID). These credentials are essential for integration and automation—especially for connecting your repo to SonarQube scans. Take notes and store these values securely. Codespaces environments can be [DO]rebuilt or shut down at any time, so keeping track ensures you can recover and restart everything quickly.

**LO1-V4:GITHUB-APP-CONNECTOR-TELL-SHOW**  
For GitHub integration, we’re using GitHub App connectors to allow apps to interact securely with your environment. You’ll need to [SHOW]grant access and manage the connection properly. As mentioned earlier, it’s crucial to store your configuration details—like App ID, Client ID, and secrets—safely. Use systems like LastPass or a secured text file on a trusted cloud provider to hold your security notes. [DO]Connect the GitHub App to your environment to enable automated scans and background operations. This setup ensures consistent access and control, even if Codespaces is restarted or rebuilt.

**LO1-V4:GITHUB-KEY-GENERATION-TELL-SHOW**  
We are going to generate the keys needed to secure the GitHub environment. Your **Developer Settings** in GitHub will be the main area where this happens. In your GitHub application, you’ll [SHOW]generate and manage these keys, including the private key and webhook secret. All of these should be placed into the same [DO]configuration file you use for the App ID and Client ID. Keeping everything together ensures the system can be easily restored or reused when rebuilding Codespaces. This step is essential for maintaining a secure and functional integration between GitHub and your SonarQube environment.

**LO1-V4:PRIVATE-KEY-PAM-FILE-TELL-SHOW**  
One of the key files you’ll generate is the **.pem** (Privacy Enhanced Mail) file for your private key. This file is sensitive and should **never** be committed to source control. [DO]Use a `.gitignore` file to exclude it from your repo. The `.pem` file can be large and may create a cache—so you’ll want to handle it carefully.  
Store this file securely in a configuration system like **LastPass**, **1Password**, or a trusted cloud storage service. [SHOW]Learn how to open and read this file using tools like `cat` or a text editor, so you can validate or migrate it when needed.

## **LO1-V4:PEM-FILE-HANDLING-TELL-SHOW**  
To manipulate `.pem` files, you can use **Notepad** or any text editor to view the content. [SHOW]Look for the markers:  
`-----BEGIN RSA PRIVATE KEY-----`  
`-----END RSA PRIVATE KEY-----`  
Make sure to **copy the entire content**, including the headers and footers. [DO]Paste it into a secure location like LastPass or your configuration vault. The private key works **together** with the public key—so you need to store **both**. If you only save the private key, remember the public key may already be on the server. Keeping both ensures you can rebuild or reauthenticate without issues.

#### **LO1-V4:GITHUB-WEBHOOK-CONFIG-TELL-SHOW** 🔗  
You’ll set up a **webhook** so GitHub can notify your systems whenever changes occur in your repo. Your code lives in GitHub—either as a public open-source repo or a private one. It’s a central and secure place to manage your code. [SHOW] SonarQube provides a **webhook URL** that tells the agent where to send scan events.  
[DO] One agent can send events to multiple URLs, so it’s your job to configure it properly. 🎯 Assign the correct webhook to your project so events flow to the right place, enabling automated scans and CI workflows. ⚙️

#### **LO1-V4:ENVIRONMENT-COMPONENTS-TELL-SHOW** 🧩  
To understand the full setup, break down the key components: your **Dev environment** (the browser + GitHub Codespaces), where you’ll enter and start building. Inside Codespaces, you’ll run **Minikube** and install YAML templates to deploy **SonarQube**.  
[SHOW](4.9.7) SonarQube will connect to your **GitHub repo** using **webhooks**, and trigger **GitHub Actions** for CI events.  
[DO](4.9.7.B) All these components—Dev tools, Minikube, SonarQube, GitHub, webhooks, and actions—must work together continuously. 🔁 This integration helps track and resolve issues at every step, making sure your codebase is always being scanned and improved. ✅ By paying the technical debt

#### **LO1-V4:GITHUB-APP-PERMISSIONS-TELL-SHOW** 🔐  
When integrating your app with GitHub, you’ll define **access levels and permissions** across your repos. With 100+ repos and 100+ permission types, it’s important to manage access efficiently. [SHOW](4.9.8) In an enterprise environment, access is usually assigned **repo by repo**, specifying if the app can merge PRs, read code, or write to branches.  
[DO] For training or quick setup, you can assign permissions in **bulk**. If you're unsure, give access temporarily—then **delete the app** when you're done. ⚠️ Always consider security. Granting only what's needed reduces risks and helps you manage trusted integrations responsibly. 🛡️

#### **LO1-V4:SELECT-REPO-AND-DEPLOY-TELL-SHOW** 🗂️  
Select your **GitHub repo** and [SHOW] **dismiss the top update message**—it can lead to unnecessary distractions or "yak shaving" 🐃. We’re using a **YAML structure** to deploy SonarQube, which makes version updates simple and repeatable.  
[DO] The CI system will use the repo you choose on this screen to trigger scans. I’ve selected our existing **SonarQube repo**, and that’s perfectly fine. Once scanning starts, any issues will be shown in the results panel and you'll get notifications to address them. ✅ Keep things clean, focused, and version-controlled.

#### **LO1-V4:SETUP-SCANNING-AGENT-TELL-SHOW** 🤖  
To scan your project, you’ll need an **agent**—in our case, that's **GitHub Actions**, which runs directly inside GitHub. [SHOW] Since your repo is already on GitHub, the agent can easily find and scan it—location matters here. Keeping everything inside GitHub simplifies access and reduces setup friction.  
[DO] For this **proof of concept**, we’re skipping complex security layers and network restrictions. 🧪 The goal is to scan your code easily, test the setup, and allow controlled failures. In a **production setup**, you’d add multiple security zones, but for now, speed and simplicity are key. 🚀

#### **LO1-V4:PROJECT-SCANNING-TRIGGERS-TELL-SHOW** 🔄  
Set up your project for scanning, and make sure your **CI system works side-by-side** with SonarQube. [SHOW] It’s not enough to just link the project—you need to create **automated triggers**. These can fire on every commit, on a daily or weekly schedule, or based on specific conditions.  
[DO] These scans will automatically analyze your code and notify **stakeholders** via email, Slack, or Teams. 📬 Once this system is in place, it becomes part of your workflow. You'll start receiving regular reports from the agent, making continuous analysis a seamless part of your development life. 🛠️

#### **LO2-V4:START-GITHUB-ACTIONS-WITH-YAML-TELL-SHOW** ⚙️  
To get GitHub Actions running, start with a **simple YAML workflow**. [SHOW] YAML (Yet Another Markup Language) is the backbone of most modern platform configurations—essential for defining CI/CD pipelines, infrastructure, and deployment rules.  
[DO] I recommend using **GPT to help generate or review** your YAML files. In this repo, all prompts and examples are GPT-assisted. Ask it to explain or **add comments** if anything feels unclear. This makes your workflows not just functional, but understandable. YAML is your **config language for infra**, so mastering it will pay off across platforms. 🧠📁

#### **LO2-V4:COMMIT-TIMING-AND-QUALITY-ANALYSIS-TELL-SHOW** ⏱️  
Understanding **commit timing** is crucial when working with Git repositories. Since you're using **Codespaces**, Git is already installed, and you're working with a browser-based IDE. [SHOW] Each commit is like a **cell division in your system's DNA**—whenever you change code, it gets replicated.  
[DO] It's essential to **pay down technical debt** with each commit. SonarQube will automatically analyze each commit and flag any **quality issues**. 🚨 The trigger for this analysis is vital: it ensures that as soon as a commit happens, potential problems are identified early, helping you maintain high-quality, clean code. 🧑‍💻


#### **LO2-V4:HANDS-ON-SONARQUBE-DEPLOYMENT-TELL-SHOW** 🛠️  
In this **hands-on experience**, you'll create your own **GitHub environment**. Start by creating a GitHub account and a new repository. You can either **fork** my repo or **start from scratch**. [SHOW] Ensure that you complete all sign-up steps to get your environment set up.  
[DO] The **free-tier Codespaces** should work fine for this project, but if you want to keep your system from shutting down, consider upgrading. Your main goal is to **deploy a SonarQube cluster** within a **Minikube** environment. Minikube is a small, local Kubernetes cluster that will let you see the **SonarQube UI** running directly within your setup. This step is crucial to see SonarQube in action and interact with the analysis process! 🚀

#### **L02-In-Video Question** 🎥
What do you think about the environments we've set up for this section? Do you feel comfortable using **Codespaces** and a **browser-based approach**? Is your **internet connection stable** enough to handle this setup? Are you planning to use **Mac** or **Windows** for this project? Do you feel confident following the **AI-driven setup** process? Lastly, have you explored the **SonarQube environment**? Everything we’ve covered should be replicable on your end. Remember to check the **GitHub repo** where I’ve recorded every step. You should be able to reverse engineer the setup by reviewing the repository. 
Please answer all of these questions to reflect on your progress! 😊

#### **LO1-V4:YAML-CONNECTS-SYSTEM-TELL-SHOW**  
YAML plays a crucial role in connecting various parts of the system. In the SonarQube ecosystem, you'll see the use of multiple layers of Linux environments. Initially, you're working within a **Linux inside another Linux** to trigger processes. Here's how it works:  
1. **Checkout the code**: The first step is to pull the repository code.  
2. **Scan the repository**: Once the code is checked out, the scan process begins.  
3. **Key components**: To run the scan, two essential pieces are required:
   - **Token**: For authentication.
   - **Host URL**: To connect to the scanning service.  
4. **GitHub Actions**: These actions are set to first check out the code and then trigger the scan with SonarQube.  
This setup allows the **GitHub Actions** to understand that after the code is checked out, it will automatically run the scan and execute the necessary build processes accordingly.

#### **LO1-V4:ENVIRONMENT-VARIABLES-TELL-SHOW**  
When working on remote systems, **environment variables** are your best friend 🖥️. They are crucial in any system—Linux 🐧, DOS, or macOS 🍏. To get the most out of your environment, **load these variables** 🛠️. If you're using GitHub Codespaces, you’ll directly interact with these environment variables.  
To familiarize yourself with them:  
- Use the **terminal** 🖥️ (Mac Terminal, Windows PowerShell).
- Use **GPT** 💬 to understand the concept of environment variables and how they function in your setup.  
These variables are key to configuring the system properly ⚙️. If you can't set them correctly, the system won't be able to run your jobs for SonarQube.

#### **LO1-V5:ENVIRONMENT-VARIABLES-POWER-AND-USAGE-TELL-SHOW** 🌍
Working on remote systems? Environment variables will be your best friend. [SHOW] These variables are used across Windows (PowerShell), macOS (Terminal), and Linux systems to pass configuration values like tokens, URLs, and secret keys into your runtime environments. They are also essential in CI/CD systems like GitHub Codespaces or GitHub Actions.
[DO] Try setting them in your local terminal to get hands-on practice:
In PowerShell:
powershell
Copy code
$env:MY_VARIABLE = "my_value"
echo $env:MY_VARIABLE
In macOS/Linux:
bash
Copy code
export MY_VARIABLE="my_value"
echo $MY_VARIABLE
Use GPT to explain any part of this you don’t fully get—ask it “What is an environment variable?” or “Why use these in CI/CD?” 🧠🔐 Mastering this will help you securely configure systems without hardcoding values into your code.

#### LO1-V6:TRIGGER-SCAN-AFTER-COMMIT-TELL-SHOW 🔁
Every commit triggers a scan process via GitHub Actions. [SHOW] You’ll see this in your repo’s Actions tab—each workflow run shows live status like ✅ success or ❌ fail, helping you trace issues quickly.
[DO] Expect friendly fails at the beginning! That’s normal. SonarQube checks your code for technical debt, and it’ll highlight issues automatically. Your job is to identify the root cause and apply improvements. Don’t rush to pass everything; instead, define a reasonable quality gate—code should meet basic standards without blocking all progress. Learn to strike a balance between quality enforcement and dev speed. 🚦🛠️

#### LO1-V8:UNDERSTAND-COSTS-OF-AGENTS-TELL-SHOW 💸
When running GitHub Actions or using CodeSpaces, it's important to understand what you’re actually paying for. [SHOW] In this setup, the agent (GitHub Actions) is serverless, meaning you don’t own or run a full-time server—it spins up on demand, does the job, and shuts down. That’s why the cost is low: around $4/month for V40s agents and associated CodeSpaces.
[DO] Think of it like renting a car 🚗—you only pay when you drive. Serverless infrastructure is cost-efficient when you don’t need 24/7 uptime. Instead of paying to keep a host always on, GitHub gives you shared infra, which is perfect for CI/CD jobs that run for short bursts. Use this model wisely to optimize your spending while getting powerful compute on demand. 🧮📊

#### **LO1-V9:ENHANCE-CODE-SHARING-WITH-IDES-TELL-SHOW** 🧑‍💻🔗  
Working with GitHub commits is easier when using a **desktop IDE** like **Visual Studio** or **VS Code**. [SHOW] These tools offer powerful features and **extensions**—and you can even use them **inside GitHub CodeSpaces**. One essential extension is **"Copy GitHub URL"**, which lets you right-click any file or line and get a direct link to share with your team.
[DO] Whether in CodeSpaces or on your **local machine**, make sure to install helpful extensions that **sync across devices** using your Microsoft account. When SonarQube flags issues, you’ll need to **share specific file locations** easily. Use these tools to collaborate faster, debug smarter, and level up your dev setup. 🚀🧩

#### **LO1-V10:SHARE-SONARQUBE-INSIGHTS-WITH-YOUR-TEAM-TELL-SHOW** 🤝🔍  
As mentioned earlier, the main goal of using **SonarQube** is to **pay down technical debt**. [SHOW] You're operating in an **open-source mindset**—this means actively **sharing URLs**, reviewing feedback, and collaborating with teammates to improve code quality.
[DO] Don’t isolate yourself—**avoid working in silos**. Use features like **“Copy GitHub URL”** or **SonarQube report links** to initiate conversations. Drop those links into Slack, Teams, or pull request comments. Make it a habit to **discuss code issues openly**, and **learn from your team’s perspective**. SonarQube isn’t just about finding problems—it’s a **learning experience** that gets better the more you collaborate. 🌱📎

#### **LO1-V11:USE-URLS-MARKDOWNS-AND-INDEXES-TO-COMMUNICATE-CODE-TELL-SHOW** 🔗🗂️  
When working in **GitHub Codespaces**, you’ll notice that **sharing URLs**, **committing clearly**, and **naming resources** becomes a critical part of your workflow. [SHOW] This is a browser-based IDE, but the same concepts apply across environments—**indexing your folders**, using meaningful names like `048-UI`, and **organizing with Markdown** all help make your system more readable.
[DO] Use GPT to help maintain structure and clarity. Maintain a personal index structure and be consistent. Markdown is your **visual communicator**—make sure your READMEs, documentation, and code comments are easy to follow. As you introduce concepts like **technical debt**, your job will also be to **explain it well to non-technical stakeholders**. Communicating is coding—**index smart, document clear, and share responsibly**. 📚💬

#### **LO1-V12:VISUALIZE-TECHNICAL-DEBT-WITH-EXTENSIONS-TELL-SHOW** 🧩📊  
Using **extensions for SonarQube, YAML, and Markdown** takes your coding experience beyond text—it becomes **a visual game** where managing **technical debt** feels structured and clear. [SHOW] With IDE plugins and GitHub integrations, you’ll start to **see issues before they grow**, understand error highlights, and grasp complexity via visuals.
[DO] Install key extensions in **Codespaces or local VS Code**, including SonarQube support, Markdown preview, and YAML validators. These make it easier to **spot issues, explain problems, and collaborate**. Leverage **GPT to help comment, structure, and write your Markdown**, especially when documenting technical decisions. Your goal? **No more cryptic folders or hidden logic**. Every file should be understandable—even if you come back to it months later. 🛠️📂

#### **LO1-V13:SHOWCASE-SONARQUBE-IN-YOUR-CAREER-TELL-SHOW** 🎯💼  
As an instructor or developer, **making your work visual and measurable boosts both credibility and career growth**. [SHOW] SonarQube isn’t just a tool—it’s a **career asset**. Mentioning it in your **CV, LinkedIn, and GitHub projects** shows you care about clean code and scalable systems.
[DO] If you're using SonarQube in projects—especially in tools like your **Delivery Pilot**—**document it clearly**. Share your learnings, screenshots, and metrics. Mention how it helped you **reduce technical debt** and improve code quality. Add it as a skill on LinkedIn and explain your usage in project descriptions. Recruiters and teams value professionals who don't just write code, but improve its health and maintainability. 🛠️🚀

#### **LO1-V14:USE-SONARQUBE-AS-A-CREDIT-SCORE-TELL-SHOW** 📊🌍  
In the future, your **technical debt score** will be just as important as your credit score. [SHOW] LinkedIn and other professional platforms are already asking for **GitHub URLs** on project listings, and **SonarQube** is key to demonstrating the **quality** of your code. It's no longer enough to show *just* your projects—you need to show **quality projects**. SonarQube helps you do that by tracking **technical debt** and offering insights on how to improve.
[DO] Treat your GitHub as your **digital portfolio**, and SonarQube as your **proof of quality**. By actively monitoring and improving your code quality, you'll signal to future employers or collaborators that you’re serious about **software craftsmanship**. **Open-source contributions** are great, but **well-maintained, high-quality contributions** will make your profile stand out even more. **AI systems** and **recruiters** alike will take notice of your work. 📚💼
And if you need guidance on this concept, there's a book called **"Show Your Work"** by Austin Kleon that perfectly aligns with this idea. It’s all about making your work visible and building your personal brand as a developer. 🌟

#### **LO1-V15:INTEGRATE-SONARQUBE-INTO-YOUR-PROJECTS-TELL-SHOW** 📈🔗  
When you work with **SonarQube**, you're not just improving code quality—you're also building a **digital history**. [SHOW] By tracking and committing your work on **GitHub** and integrating **SonarQube** into your projects, you create a clear trail of your progress. This helps you document every stage of your development process, from **initial integration** to resolving technical debt and improving code quality.
[DO] **Make sure to mention SonarQube in your projects**, both on GitHub and on platforms like **LinkedIn**. This not only showcases your technical ability but also highlights that you’re committed to maintaining **enterprise-level quality**. It demonstrates to recruiters or collaborators that you're actively working on **scalable, high-quality solutions**—something that stands out in the competitive tech world. 🔍💡
Your **GitHub history** becomes your **proof** of expertise, and **SonarQube** acts as a tool that documents and improves that expertise. When you explain your projects, share how **SonarQube** helped you reach **quality gates**, address technical debt, and ensure sustainable development. **Let others see how you’re growing**, and make your work visible to the broader tech community. 🌐👩‍💻👨‍💻

#### **LO1-V16:INTEGRATE-SONARQUBE-INTO-DAY-TO-DAY-DEVELOPMENT-TELL-SHOW** 🔄🔍  
As you work on your projects, you’re not just coding—you’re **actively managing and improving** your **technical debt**. [SHOW] By integrating **SonarQube** into your **development lifecycle**, you ensure that every piece of code is consistently **scanned for quality**. The **GitHub history** becomes a **living record** of your work, capturing every update, every fix, and every improvement to your code.  
[DO] Treat **SonarQube** as part of your **daily development process**. **Clean up technical debt every day**, whether it’s a small change or a major update. The more **SonarQube scans** you complete, the **higher the quality** of your software development lifecycle becomes. This consistent process shows **progress** in real time, proving your commitment to **quality code**.
Use **Markdowns**, **visual tools**, and **structured indexing** to make your **SonarQube results** clearer and more actionable. This not only makes it easier to understand the issues but also allows you to **track improvements over time**. The more you update your code with **SonarQube’s recommendations**, the stronger your **developer portfolio** becomes. Keep showing your work, keep improving, and stay ahead of technical debt! 📈💻.

#### **LO1-V17:RECONNECT-AND-PAY-OFF-TECHNICAL-DEBT-TELL-SHOW** 🔄💳  
Think of **technical debt** as a **contract**—just like using a credit card for purchases, there's an ongoing responsibility to **pay off the debt**. [SHOW] If you stop paying, systems like **SonarQube**, **infrastructure**, and **code repositories** may shut down, and everything you've worked on will stop functioning. When you stop the system, you lose all progress unless you **reinitialize** the process.  
[DO] Always be ready to **pay off your technical debt** and **reconnect** the necessary components when they stop. This includes **reinitializing your setup**, such as the **mini Cube** or **GitHub Actions**, and following the steps outlined in the **underscore input** directory (located in the `second_minikube folder). Understand that each time you iterate, you need to **keep the debt paid off**—or else, your **development cycle** might grind to a halt.
It’s a simple but critical process: if you stop paying for the infrastructure, it **shuts down**. The key is knowing how to **reconnect** and keep everything running smoothly, ensuring that your **technical debt** doesn’t prevent progress. 🚧⚙️



# Passive Script ReRead and Remove 


**Slide 5 - Setting up the Environment**

"Let's now focus on setting up the environment for SonarQube. First, you need to download and install SonarQube. You can download SonarQube from their official website. SonarQube is available in various editions. However, the Community Edition is sufficient for most developers, and it's free. Once the download is complete, extract the zip file. There, you'll find a directory named 'bin'. Inside it, you'll find the script files to start SonarQube."

**Demonstration Slide - Setting up Environment (optional)**

"Once you've carried out these instructions and started SonarQube, just open a web browser and enter 'localhost:9000'. This should open the SonarQube dashboard. If everything worked correctly, congratulations, you've set up your SonarQube environment!"

---

**Slide 6 - Summary**

"To summarize, we've covered the important concept of what SonarQube is, looked at its benefits, and walked through the process of setting up the SonarQube environment. Hopefully, you should now understand how valuable SonarQube can be in maintaining and improving code quality."

---

**Slide 7 - Next Steps**

"Great job on completing this first module. In the next module, we'll dive deeper into working with SonarQube, understanding the interface, and carrying out the initial code analysis tasks. So, stay tuned and keep working on improving the code quality with SonarQube!”

---

MD files have been used to format this script to make it easy to follow along during the narration and visual presentation. The script contains the dialogue in the speaker notes, while the slide number and title are marked as headers. Important content options are highlighted as bullet-pointed lists. Code or commands are formatted in `Monaco` style for easy recognition.



## Video 2: Setting Up SonarQube with Minikube

## Introduction (30s)
Welcome back! In this video, we'll set up SonarQube using Minikube in a development environment. We'll configure the essential components to get your code quality analysis platform running.

## Prerequisites Check (30s)
Before we begin, ensure you have:
- Minikube installed
- kubectl configured
- 4GB RAM available
- Docker running

## Main Content (3m)

### 1. Starting Minikube (45s)
Let's start by configuring our Minikube cluster:
```bash
minikube start --driver=docker --cpus=2 --memory=4096MB --kubernetes-version=stable
```
This creates a cluster with sufficient resources for SonarQube.

### 2. Configuring Environment (45s)
First, create a namespace and storage:
```bash
kubectl create namespace sonarqube
kubectl apply -f pvc.yaml
```

### 3. Deploying Components (45s)
Deploy PostgreSQL and SonarQube:
```bash
kubectl apply -f deployment_postgresql.yaml
kubectl apply -f deployment_server.yaml
```

### 4. Accessing SonarQube (45s)
Enable access through port forwarding:
```bash
kubectl port-forward -n sonarqube svc/sonarqube 9000:9000
```

## Knowledge Check (30s)
> Which command verifies if your SonarQube pods are running correctly?
> a) kubectl get pods
> b) kubectl get pods -n sonarqube
> c) minikube status
> d) kubectl status
> (Answer: b) kubectl get pods -n sonarqube)

## Additional Resources (30s)
For detailed configuration options, visit the official SonarQube Kubernetes deployment guide at:
https://docs.sonarqube.org/latest/setup-and-upgrade/deploy-on-kubernetes/

## Summary
You've now set up a working SonarQube instance in your development environment using Minikube. In our next video, we'll explore how to analyze your first project.

This script focuses on practical setup steps while maintaining engagement through clear instructions and a relevant knowledge check. It aligns with the learning objective of setting up SonarQube in a development environment and achieves the key result of configuring Minikube and SonarQube.This script focuses on practical setup steps while maintaining engagement through clear instructions and a relevant knowledge check. It aligns with the learning objective of setting up SonarQube in a development environment and achieves the key result of configuring Minikube and SonarQube.


---



## Video 3: Integrating GitHub with SonarQube

## Introduction (30s)
Welcome back! In this video, we'll connect GitHub with SonarQube to enable automated code analysis. We'll set up a GitHub App and configure our first repository scan.

## Prerequisites Check (30s)
Before we begin, ensure you have:
- SonarQube running (from previous video)
- GitHub account with admin access
- Repository to analyze
- Access to GitHub Actions

## Main Content (3m)

### 1. Creating GitHub Secrets (45s)
First, let's set up authentication:
- Go to your GitHub repository settings
- Navigate to Secrets and Variables > Actions
- Create two new secrets:
  ```bash
  SONAR_TOKEN=<your-token>
  SONAR_HOST_URL=<your-sonarqube-url>

## Module 3: Integrating SonarQube with CI/CD

## INTRODUCTION

**[Speaker Notes]**

Hello, and welcome back to "Code Quality with SonarQube". This module number three is titled "Integrating SonarQube with CI/CD". 

## CONCEPT EXPLANATION

**[Speaker Notes]**

The key objective of this module is to show you how we can integrate SonarQube into the Continuous Integration and Continuous Deployment process, usually abbreviated as CI/CD.

By integrating SonarQube with CI/CD, we ensure the code quality is kept in check automatically at every code commit and before each deployment to different environments.

## PRACTICAL DEMONSTRATION

**[Speaker Notes]**

Let's start with an example using Jenkins, a popular CI/CD tool. 

In your Jenkins job, typically you'll add a build step to execute shell commands for starting a SonarQube analysis. In your Jenkins Pipeline's script, you'll introduce stages that call `mvn sonar:sonar` or similar commands depending on the build tool in use. The `-Dsonar.host.url` and `-Dsonar.login` parameters are used to specify the URL of the SonarQube server and the authentication.

Next, in the SonarQube server, go to the administration section, under 'CI/CD Integration'. Here, generate a token and use it in Jenkins to allow the CI/CD pipeline to interact with SonarQube.

Remember, it is important to fail the build when quality gate checks fail, which you achieve by adding a quality gate status check in Jenkins.

## SUMMARY

**[Speaker Notes]**

Just to recap, we covered the need for integrating SonarQube into CI/CD. We walked through an example of how this integration can be done using Jenkins. Finally, we learned how to fail the build when the code quality checks don't pass so that issues can be addressed immediately.

Integrating SonarQube with CI/CD is a powerful way to enforce quality checks throughout the development process, leading to cleaner and more reliable code.

---

(Note: There is no transition to next module since this is the final module.)
  
This concludes our third and final module, "Integrating SonarQube with CI/CD". Hopefully, you now have a clearer understanding on how to leverage SonarQube to its full capacities and increase your code's quality. Keep practicing, and soon you will see the tangible benefits of using this tool in your projects. Thank you for staying with us. Happy coding!

## Lo2 Video 1 Script

**COURSE TITLE:** Code Quality With SonarQube

**MODULE TITLE:** Analyzing Code with SonarQube

`---------------------------------------------------------------`

**[0:00 - 0:30] Introduction**

**(Speaker)**
_* (A slide showing the module title "Analyzing Code with SonarQube")*_

Hello everyone, I welcome you all to the second module of our course, "Code Quality with SonarQube". In this module, we will dive deeper into how to analyze code with SonarQube. Remember, code analysis will help you detect bugs and vulnerabilities, maintain code quality, and improve your software’s reliability over time.

`---------------------------------------------------------------`

**[0:30 - 1:30] Concept Explanation**  

**(Speaker)**
_* (Show a slide displaying the SonarQube interface with an annotated part indicating the code analysis section)*_

So, how does SonarQube analysis work?

SonarQube analysis is based on source files. It reads and interprets the code, using various language plugins. It performs issue detection, measures code coverage, computes duplication and complexity, and generates coding rule metrics. Also, it provides an overview of the quality of code. This is invaluable as it gives us pointers on where to focus our code improvement efforts.

`---------------------------------------------------------------`

**[1:30 - 3:30] Practical Example**

**(Speaker)**
_* (Show a code snippet on the screen)*_

Now, let's run through a practical example. 

Here, we have a piece of Java code. The code is not entirely bad, but we suspect it contains some vulnerabilities that could pose a risk to our application.

_* (Show how to run the code analysis in the SonarQube interface)*_

As you can observe, we will first set up SonarQube, pointing it at our codebase, then run the scanning process. 

Let's look at the results. 

_* (SonarQube dashboard displays the code issues)*_

See, it detected some code smells, security hotspots, and even a couple of bugs! And just like that, we can see where our attention is needed. 

And not only that, but SonarQube also points you directly to the problematic lines of code and offers tips on how to refactor them to enhance our code quality.

Now, isn't that insightful?

`---------------------------------------------------------------`

**[3:30 - 3:50] Summary**

**(Speaker)**
_* ( A slide displaying key points of the module)*_

In summary, an essential tool in maintaining high-quality code is conducting regular, thorough analyses. SonarQube not only detect issues but can also help you learn and adopt coding best practices, ultimately making you a better developer.

`---------------------------------------------------------------`

**[3:50 - 4:00] Transition to Next Module**

**(Speaker)**

With this essential knowledge about code analysis in SonarQube, we are ready to move to our third and final module. In the final module, we will explore more advanced use-cases, and you'll learn how to integrate SonarQube into your CI/CD pipelines for automated code quality checks. So, stay tuned!

`---------------------------------------------------------------`

**End of Module 2**

## Outro

### **Promo Video Script: Course Overview**  

#### **Opening Hook (5-10 sec)**  
🎥 **[Visual: High-energy montage of students engaging with the course, smiling, taking notes, or interacting with instructors.]**  
🎙️ **Voiceover (enthusiastic tone)**:  
*"Ready to transform your skills and unlock new opportunities? [Course Name] is your gateway to mastery!"*  

#### **Course Value (15-20 sec)**  
🎥 **[Visual: Split-screen of "Before" (struggling learner) vs. "After" (confident professional applying skills).]**  
🎙️ **Voiceover**:  
*"Struggling with [problem the course solves]? Our step-by-step program helps you [key benefit 1], [key benefit 2], and [key benefit 3]—faster than you think!"*  

#### **Social Proof (10 sec)**  
🎥 **[Visual: Testimonial clips from past students or text quotes with photos.]**  
🎙️ **CaseStudy 1 *"SonarQube changed everything!"*  
🎙️ **CaseStudy 2**: *"SonarQube made complex topics feel simple."*  

#### **Call-to-Action (10 sec)**  
🎥 **[Visual: Instructor pointing at the camera or animated "Enroll Now" button.]**  
🎙️ **Voiceover**:  
*"Don’t wait! Join [X] students today. Enroll now at [Website URL]—offer ends soon!"*  

#### **Closing Branding (5 sec)**  
🎥 **[Visual: Course logo + tagline.]**  
🎙️ **Voiceover**: *"[Course Name]—Where [audience, e.g., ‘beginners become experts’]."*  

---

### **Additional Notes**  
- **Music**: Upbeat, motivational track.  
- **Length**: 45-60 seconds total.  
- **Style**: Mix of live-action, text animations, and dynamic transitions.  

---

### **Promo Video Script: Course Overview**  

#### **Opening Hook (5-10 sec)**  
🎥 **[Visual: High-energy montage of students engaging with the course, smiling, taking notes, or interacting with instructors.]**  
🎙️ **Voiceover (enthusiastic tone)**:  
*"Ready to transform your skills and unlock new opportunities? [Course Name] is your gateway to mastery!"*  

#### **Course Value (15-20 sec)**  
🎥 **[Visual: Split-screen of "Before" (struggling learner) vs. "After" (confident professional applying skills).]**  
🎙️ **Voiceover**:  
*"Struggling with [problem the course solves]? Our step-by-step program helps you [key benefit 1], [key benefit 2], and [key benefit 3]—faster than you think!"*  

#### **Social Proof (10 sec)**  
🎥 **[Visual: Testimonial clips from past students or text quotes with photos.]**  
🎙️ **CaseStudy 1 *"SonarQube changed everything!"*  
🎙️ **CaseStudy 2**: *"SonarQube made complex topics feel simple."*  

#### **Call-to-Action (10 sec)**  
🎥 **[Visual: Instructor pointing at the camera or animated "Enroll Now" button.]**  
🎙️ **Voiceover**:  
*"Don’t wait! Join [X] students today. Enroll now at [Website URL]—offer ends soon!"*  

#### **Closing Branding (5 sec)**  
🎥 **[Visual: Course logo + tagline.]**  
🎙️ **Voiceover**: *"[Course Name]—Where [audience, e.g., ‘beginners become experts’]."*  

---

### **Additional Notes**  
- **Music**: Upbeat, motivational track.  
- **Length**: 45-60 seconds total.  
- **Style**: Mix of live-action, text animations, and dynamic transitions.  


